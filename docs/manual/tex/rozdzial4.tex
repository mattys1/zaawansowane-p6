	\newpage
\section{Implementacja}		%4
%Opisać implementacje algorytmu/programu. Pokazać ciekawe fragmenty kodu
%Opisać powstałe wyniki (algorytmu/nrzędzia)

\subsection{Ogólne informacje o implementacji klas}

Program podzielony jest na wiele plików, w tym rozdziale zostaną opisane funkcjonalności każdego z nich.

\subsubsection{MeasurementsImporter.hpp oraz MeasurementsImporter.cpp}

Klasa została podzielona na dwa pliki: .hpp oraz .cpp. Na listingu nr \ref{lst:msimporter} przedstawiona została zawawrtość pliku \texttt{MeasurementsImporter.hpp}.

\begin{lstlisting}[caption=Zawartość pliku \texttt{MeasurementsImporter.hpp}, label={lst:msimporter}, language=C++]
	#pragma once
	#include "MeasurementRecord.hpp"
	#include <string_view>
	#include <vector>
	#include <fstream>
	
	class MeasurementsImporter {
		private:
		std::vector<MeasurementRecord> records;
		public:
		void read_measurements(const std::string_view fileName); 
		std::vector<MeasurementRecord> get_records() const;
	};
\end{lstlisting}

Na listingu nr \ref{lst:msimportercpp} przedstawiona została zawartość pliku \texttt{MeasurementsImporter.cpp.}

\begin{lstlisting}[caption=Zawartość pliku \texttt{MeasurementsImporter.cpp}, label={lst:msimportercpp}, language=C++]
	#include "MeasurementsImporter.hpp"
	#include <algorithm>
	#include <cassert>
	#include <chrono>
	#include <ranges>
	#include <variant>
	
	void MeasurementsImporter::read_measurements(const std::string_view fileName) {
		const auto check_for_double { [this](const MeasurementRecord& record) -> bool {
				return std::ranges::find(records, record) != records.end();
		}};
		
		const auto log { [](std::string_view line, std::fstream& file) {
				const auto time { std::chrono::system_clock::now() };
				
				file << std::format("{}: Loading record: {}\n", time, line);
		}};
		
		const auto log_err { [](std::string_view line, const std::string_view message, std::fstream& file) {
				const auto time { std::chrono::system_clock::now() };
				
				file << std::format("{}: {}: {}\n", time, message, line);
		}};
		
		std::fstream measurementsFile;
		measurementsFile.open(fileName.data(), std::fstream::in);
		
		if(!measurementsFile.is_open()) {
			throw std::runtime_error("Could not open input file");
		}
		
		std::fstream errorLogs; errorLogs.open("log_error_data_godzina.txt", std::fstream::app);
		if(!errorLogs.is_open()) {
			throw std::runtime_error("Could not open error log file");
		}
		
		std::fstream allLogs; allLogs.open("log_data_godzina.txt", std::fstream::app);
		if(!allLogs.is_open()) {
			throw std::runtime_error("Could not open log file");
		}
		
		std::vector<std::string> lines;
		std::string line; 
		while(std::getline(measurementsFile, line)) {
			if(line.empty() || std::find_if(line.begin(), line.end(), [](const auto ch) { return !isspace(ch); }) == line.end()) {
				continue;
			};
			
			log(line, allLogs);
			
			if(const auto invalid = std::find_if(line.begin(), line.end(), [](const auto x) {
				return !((x >= '0' && x <= '9') || x == '.' || x == ',' || x == ':' || x == '\"' || isspace(x));
			}); invalid != line.end()) {
				log_err(line, "Line with invalid characters", errorLogs);
				continue;
			}
			
			lines.emplace_back(line);
		}
		
		if(lines.size() == 0) {
			return;
		}
		
		records.reserve(lines.size());
		for(const auto& line : lines) {
			auto entries { std::views::split(line, ',') | std::ranges::to<std::vector<std::string>>() };
			
			if(entries.size() != 6) {
				log_err(line, "Invalid entry size", errorLogs);
				continue;
			}
			
			const auto DateAndHourTime { entries[0] |
				std::views::split(' ') |
				std::ranges::to<std::vector<std::string>>() };
			
			const auto& date { DateAndHourTime[0] }, hourTime { DateAndHourTime[1] };
			
			const auto splitDate { date |
				std::views::split('.') |
				std::ranges::to<std::vector<std::string>>() };
			
			const auto& day { splitDate[0] }, month { splitDate[1] }, year { splitDate[2] };
			
			for(auto& x : entries) {
				x.erase(remove(x.begin(), x.end(), '\"'), x.end());
			}
			
			const auto minutesPerQuarter { 24 * 60 / 4 };
			
			const auto hoursMinutes { hourTime |
				std::views::split(':') |
				std::ranges::to<std::vector<std::string>>()
				/* std::ranges::to<std::vector<std::string>>() }; */
		};
		
		const auto timeInMinutes { std::stoi(hoursMinutes[0]) * 60 + std::stoi(hoursMinutes[1]) };
		
		/* return timeInMinutes / minutesPerQuarter + 1; */
		
		const auto record { [&]() -> std::variant<MeasurementRecord, std::exception> const {
				try {
					return MeasurementRecord {
						.time = {
							.year = std::stoi(year),
							.month = std::stoi(month),
							.day =  std::stoi(day),
							.inMinutes = timeInMinutes,
							.quarter = 	timeInMinutes / minutesPerQuarter + 1				
						},
						
						.autoconsumption = std::stod(entries[1]),
						.gridExport = std::stod(entries[2]),
						.gridImport = std::stod(entries[3]),
						.consumption = std::stod(entries[4]),
						.production = std::stod(entries[5])
					};
				} catch(std::exception& e) {
					return e;
				}
			}()};
		
		if(std::holds_alternative<std::exception>(record)) {
			log_err(line, "Error converting line to values", errorLogs);
			continue;
		}
		
		if(check_for_double(std::get<MeasurementRecord>(record))) {
			log_err(line, "Line already exists", errorLogs);
			continue;
		}
		
		records.push_back(std::get<MeasurementRecord>(record));
	}
	}
	
	std::vector<MeasurementRecord> MeasurementsImporter::get_records() const {
	return records;
	}
\end{lstlisting}

Głównym zadaniem klasy jest odczytywanie zawartości pliku oraz zapisywanie ich we własnym kontenerze. Za odczyt danych z pliku odpowiedzialna jest metoda \texttt{read\_measurements} znajdująca się w wierszach od 8 do 136 na listingu nr \ref{lst:msimporter}.
Instrukcja w wiersach od 8 do 11 odpowiedzialna jest za sprawdzanie czy nie ma duplikatów.
Instrukcja w wierszach od 13 do 17 jest odpowiedzialna za logowanie poprawnych danych.
Instrukcja w wierszach od 19 do 23 jest odpowiedzialna za logowanie błędów.
Instrukcje w wierszach od 25 do 26 są odpowiedzialne za otwarcie pliku wejściowego.
Instrukcja if w wierszach od 28 do 30 jest odpowiedzialna za sprawdzanie czy plik został otwarty.
Instrukcje w wierszach od 32 do 35 są odpowiedzialne za otwarcie pliku z logami błędów.
Instrukcje w wierszach od 37 do 40 są odpowiedzialne za otwarcie pliku z logami.
Instrukcje w wierszach od 42 do 43 są odpowiedzialne za stworzenie kontenera na wszystkie linie.
Instrukcje w wierszach od 44 do 59 są odpowiedzialne za utworzenie pętli wczytującej dane z pliku. Na początku, w wierszach od 45 do 47 są instrukcje odpowiedzialne za pomijanie pustych lini lub linii z samymi białymi znakami. Następnie w wierszu 49 jest instrukcja która loguje każdą linię do pliku z logami zwykłymi. Następne instrukcje w wierszach od 61 do 57 sprawdzają czy linia zawiera dodatkowe znaki, jeżeli wystąpił błąd to logujemy do loga z błędami i przechodzimy dalej. Ostatnia instrukcja pętli w wierszu 58 dodaje linię do wektora \texttt{lines}.
Instrukcja in w wierszach od 61 do 63 sprawdza czy wczytaliśmy linie, jeżeli nie to kończy się działanie funkcji.
Instrukcje w wierszu 65 jest odpowiedzialna za rezerwację pamięci dla \texttt{records}.
Pętla for w wierszach od 66 do 135 jest odpowiedzialna za przetwarzanie każdej lini oraz konwersję do \texttt{MeasurementRecord}. Pętla zaczyna działanie od rozbicia lini po przecinku na 6 fragmentów w wierszu 67. Następnie w wierszach od 69 do 72 sprawdzane jest czy są 6 fragmentów, jeżeli nie to logujemy do logów z błędami i linia jest pomijana. Instrukcja w wierszach 74 do 78 wyciagają datę. Instrukcje znajdujące się w wierszach od 80 do 82 rozbijają datę po kropkach na dzień, miesiąc i rok.
Pętla for w wierszach od 86 do 88 jest odpowiedzialna za usuwanie cudzysłowów. Instrukcja w wierszu 90 ustala liczbę minut przypadających na ćwiartkę doby. Instrukcje w wierszach od 92 do 96 rozdzielają godziny po dwukropku na godziny i minuty.
Instrukcja w wierszu 98 jest odpowiedzialna za konwersję godziny i minuty na jedną wartość w minutach od północy.
Instrukcje w wierszach od 102 do 122 są odpowiedzialne za tworzenie rekordu w bloku lambda.
Instrukcja if w wiersach od 124 do 127 jest odpowiedzialna za czy w rekord jest poprawny rekord czy wyjątek.
Instrukcja if w wierszach od 129 do 132 jest odpowiedzialna za sprawdzenie czy wczytany rekord już istnieje.
Instrukcja w wierszu 134 dodaje nowy rekord do kontenera \texttt{records}
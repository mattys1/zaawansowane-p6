	\newpage
\section{Implementacja}		%4
%Opisać implementacje algorytmu/programu. Pokazać ciekawe fragmenty kodu
%Opisać powstałe wyniki (algorytmu/nrzędzia)

\subsection{Ogólne informacje o implementacji klas}

Program podzielony jest na wiele plików, w tym rozdziale zostaną opisane funkcjonalności każdego z nich.

\subsection{Measurement.hpp}
W tym pliku znajduje się struktura definiująca pojedynczy pomiar. Kod struktury został przedstawiony na listingu nr \ref{lst:measurementhpp}.

\begin{lstlisting}[caption=Zawartość pliku \texttt{Measurement.hpp}, label={lst:measurementhpp}, language=C++]
	#pragma once
	
	#include <compare>
	struct Measurement {
		double autoconsumption;
		double gridExport;
		double gridImport;
		double consumption;
		double production;
		int timeMinutes;
		
		auto operator<=>(const Measurement&) const = default;
	};
\end{lstlisting}
Struktura służy do przechowywania danych z pliku.

\subsection{MeasurementRecord.hpp}
W tym pliku znajduje się struktura \texttt{MeasurementRecord} wraz ze strukturą wewnętrzną \texttt{Time}. Zadaniem tej struktury jest przechowywanie mementu w czasie wraz z wartościami pomiarowymi. Struktura jest przedstawiona na listingu nr \ref{lst:measurementrechpp}.

\begin{lstlisting}[caption=Zawartość pliku \texttt{MeasurementRecord.hpp}, label={lst:measurementrechpp}, language=C++]
	#pragma once
	
	#include <compare>
	struct Measurement {
		double autoconsumption;
		double gridExport;
		double gridImport;
		double consumption;
		double production;
		int timeMinutes;
		
		auto operator<=>(const Measurement&) const = default;
	};
\end{lstlisting}

\subsubsection{MeasurementsImporter.hpp oraz MeasurementsImporter.cpp}

Klasa została podzielona na dwa pliki: .hpp oraz .cpp. Na listingu nr \ref{lst:msimporter} przedstawiona została zawawrtość pliku \texttt{MeasurementsImporter.hpp}.

\begin{lstlisting}[caption=Zawartość pliku \texttt{MeasurementsImporter.hpp}, label={lst:msimporter}, language=C++]
	#pragma once
	#include "MeasurementRecord.hpp"
	#include <string_view>
	#include <vector>
	#include <fstream>
	
	class MeasurementsImporter {
		private:
		std::vector<MeasurementRecord> records;
		public:
		void read_measurements(const std::string_view fileName); 
		std::vector<MeasurementRecord> get_records() const;
	};
\end{lstlisting}

Na listingu nr \ref{lst:msimportercpp} przedstawiona została zawartość pliku \texttt{MeasurementsImporter.cpp.}

\begin{lstlisting}[caption=Zawartość pliku \texttt{MeasurementsImporter.cpp}, label={lst:msimportercpp}, language=C++]
	#include "MeasurementsImporter.hpp"
	#include <algorithm>
	#include <cassert>
	#include <chrono>
	#include <ranges>
	#include <variant>
	
	void MeasurementsImporter::read_measurements(const std::string_view fileName) {
		const auto check_for_double { [this](const MeasurementRecord& record) -> bool {
				return std::ranges::find(records, record) != records.end();
		}};
		
		const auto log { [](std::string_view line, std::fstream& file) {
				const auto time { std::chrono::system_clock::now() };
				
				file << std::format("{}: Loading record: {}\n", time, line);
		}};
		
		const auto log_err { [](std::string_view line, const std::string_view message, std::fstream& file) {
				const auto time { std::chrono::system_clock::now() };
				
				file << std::format("{}: {}: {}\n", time, message, line);
		}};
		
		std::fstream measurementsFile;
		measurementsFile.open(fileName.data(), std::fstream::in);
		
		if(!measurementsFile.is_open()) {
			throw std::runtime_error("Could not open input file");
		}
		
		std::fstream errorLogs; errorLogs.open("log_error_data_godzina.txt", std::fstream::app);
		if(!errorLogs.is_open()) {
			throw std::runtime_error("Could not open error log file");
		}
		
		std::fstream allLogs; allLogs.open("log_data_godzina.txt", std::fstream::app);
		if(!allLogs.is_open()) {
			throw std::runtime_error("Could not open log file");
		}
		
		std::vector<std::string> lines;
		std::string line; 
		while(std::getline(measurementsFile, line)) {
			if(line.empty() || std::find_if(line.begin(), line.end(), [](const auto ch) { return !isspace(ch); }) == line.end()) {
				continue;
			};
			
			log(line, allLogs);
			
			if(const auto invalid = std::find_if(line.begin(), line.end(), [](const auto x) {
				return !((x >= '0' && x <= '9') || x == '.' || x == ',' || x == ':' || x == '\"' || isspace(x));
			}); invalid != line.end()) {
				log_err(line, "Line with invalid characters", errorLogs);
				continue;
			}
			
			lines.emplace_back(line);
		}
		
		if(lines.size() == 0) {
			return;
		}
		
		records.reserve(lines.size());
		for(const auto& line : lines) {
			auto entries { std::views::split(line, ',') | std::ranges::to<std::vector<std::string>>() };
			
			if(entries.size() != 6) {
				log_err(line, "Invalid entry size", errorLogs);
				continue;
			}
			
			const auto DateAndHourTime { entries[0] |
				std::views::split(' ') |
				std::ranges::to<std::vector<std::string>>() };
			
			const auto& date { DateAndHourTime[0] }, hourTime { DateAndHourTime[1] };
			
			const auto splitDate { date |
				std::views::split('.') |
				std::ranges::to<std::vector<std::string>>() };
			
			const auto& day { splitDate[0] }, month { splitDate[1] }, year { splitDate[2] };
			
			for(auto& x : entries) {
				x.erase(remove(x.begin(), x.end(), '\"'), x.end());
			}
			
			const auto minutesPerQuarter { 24 * 60 / 4 };
			
			const auto hoursMinutes { hourTime |
				std::views::split(':') |
				std::ranges::to<std::vector<std::string>>()
				/* std::ranges::to<std::vector<std::string>>() }; */
		};
		
		const auto timeInMinutes { std::stoi(hoursMinutes[0]) * 60 + std::stoi(hoursMinutes[1]) };
		
		/* return timeInMinutes / minutesPerQuarter + 1; */
		
		const auto record { [&]() -> std::variant<MeasurementRecord, std::exception> const {
				try {
					return MeasurementRecord {
						.time = {
							.year = std::stoi(year),
							.month = std::stoi(month),
							.day =  std::stoi(day),
							.inMinutes = timeInMinutes,
							.quarter = 	timeInMinutes / minutesPerQuarter + 1				
						},
						
						.autoconsumption = std::stod(entries[1]),
						.gridExport = std::stod(entries[2]),
						.gridImport = std::stod(entries[3]),
						.consumption = std::stod(entries[4]),
						.production = std::stod(entries[5])
					};
				} catch(std::exception& e) {
					return e;
				}
			}()};
		
		if(std::holds_alternative<std::exception>(record)) {
			log_err(line, "Error converting line to values", errorLogs);
			continue;
		}
		
		if(check_for_double(std::get<MeasurementRecord>(record))) {
			log_err(line, "Line already exists", errorLogs);
			continue;
		}
		
		records.push_back(std::get<MeasurementRecord>(record));
	}
	}
	
	std::vector<MeasurementRecord> MeasurementsImporter::get_records() const {
	return records;
	}
\end{lstlisting}

Głównym zadaniem klasy jest odczytywanie zawartości pliku oraz zapisywanie ich we własnym kontenerze. Za odczyt danych z pliku odpowiedzialna jest metoda \texttt{read\_measurements} znajdująca się w wierszach od 8 do 136 na listingu nr \ref{lst:msimporter}.
Instrukcja w wiersach od 8 do 11 odpowiedzialna jest za sprawdzanie czy nie ma duplikatów.
Instrukcja w wierszach od 13 do 17 jest odpowiedzialna za logowanie poprawnych danych.
Instrukcja w wierszach od 19 do 23 jest odpowiedzialna za logowanie błędów.
Instrukcje w wierszach od 25 do 26 są odpowiedzialne za otwarcie pliku wejściowego.
Instrukcja if w wierszach od 28 do 30 jest odpowiedzialna za sprawdzanie czy plik został otwarty.
Instrukcje w wierszach od 32 do 35 są odpowiedzialne za otwarcie pliku z logami błędów.
Instrukcje w wierszach od 37 do 40 są odpowiedzialne za otwarcie pliku z logami.
Instrukcje w wierszach od 42 do 43 są odpowiedzialne za stworzenie kontenera na wszystkie linie.
Instrukcje w wierszach od 44 do 59 są odpowiedzialne za utworzenie pętli wczytującej dane z pliku. Na początku, w wierszach od 45 do 47 są instrukcje odpowiedzialne za pomijanie pustych lini lub linii z samymi białymi znakami. Następnie w wierszu 49 jest instrukcja która loguje każdą linię do pliku z logami zwykłymi. Następne instrukcje w wierszach od 61 do 57 sprawdzają czy linia zawiera dodatkowe znaki, jeżeli wystąpił błąd to logujemy do loga z błędami i przechodzimy dalej. Ostatnia instrukcja pętli w wierszu 58 dodaje linię do wektora \texttt{lines}.
Instrukcja in w wierszach od 61 do 63 sprawdza czy wczytaliśmy linie, jeżeli nie to kończy się działanie funkcji.
Instrukcje w wierszu 65 jest odpowiedzialna za rezerwację pamięci dla \texttt{records}.
Pętla for w wierszach od 66 do 135 jest odpowiedzialna za przetwarzanie każdej lini oraz konwersję do \texttt{MeasurementRecord}. Pętla zaczyna działanie od rozbicia lini po przecinku na 6 fragmentów w wierszu 67. Następnie w wierszach od 69 do 72 sprawdzane jest czy są 6 fragmentów, jeżeli nie to logujemy do logów z błędami i linia jest pomijana. Instrukcja w wierszach 74 do 78 wyciagają datę. Instrukcje znajdujące się w wierszach od 80 do 82 rozbijają datę po kropkach na dzień, miesiąc i rok.
Pętla for w wierszach od 86 do 88 jest odpowiedzialna za usuwanie cudzysłowów. Instrukcja w wierszu 90 ustala liczbę minut przypadających na ćwiartkę doby. Instrukcje w wierszach od 92 do 96 rozdzielają godziny po dwukropku na godziny i minuty.
Instrukcja w wierszu 98 jest odpowiedzialna za konwersję godziny i minuty na jedną wartość w minutach od północy.
Instrukcje w wierszach od 102 do 122 są odpowiedzialne za tworzenie rekordu w bloku lambda.
Instrukcja if w wiersach od 124 do 127 jest odpowiedzialna za czy w rekord jest poprawny rekord czy wyjątek.
Instrukcja if w wierszach od 129 do 132 jest odpowiedzialna za sprawdzenie czy wczytany rekord już istnieje.
Instrukcja w wierszu 134 dodaje nowy rekord do kontenera \texttt{records}.

\subsection{MeasurementsTree.cpp i MeasurementsTree.hpp}

MeasurementsTree to klasa przechowująca i porządkująca pomiary, jest podzielona na dwa pliki. W pliku \texttt{MeasurementsTree.hpp} określone jest co będzie zawierać klasa \texttt{MeasurementsTree}, w pliku \texttt{MeasurementsTree.cpp} określone jest faktyczna implementacja tych metod.
Na listingu nr \ref{lst:measurementreehpp} predstawiona została zawartość pliku \texttt{MeasurementsTree.hpp}.

\begin{lstlisting}[caption=Zawartość pliku \texttt{MeasurementsTree.hpp}, label={lst:measurementreehpp}, language=C++]
	#pragma once
	
	#include <cassert>
	#include <span>
	#include <vector>
	#include "Measurement.hpp"
	#include "MeasurementRecord.hpp"
	
	class MeasurementsTree {
		private:
		using TreeType = std::vector<std::vector<std::vector<std::vector<std::vector<Measurement>>>>>;
		TreeType tree;
		
		constexpr static TreeType endDummy { TreeType {} };
		public:
		class Iterator {
			private:
			TreeType* tree;
			size_t yearIdx;
			size_t monthIdx;
			size_t dayIdx;
			size_t quarterIdx;
			size_t measurementIdx;
			
			
			int incrementSafe() {
				assert(monthIdx < (*tree)[yearIdx].size());
				assert(dayIdx < (*tree)[yearIdx][monthIdx].size());
				assert(quarterIdx < (*tree)[yearIdx][monthIdx][dayIdx].size());
				/* assert(measurementIdx < (*tree)[yearIdx][monthIdx][dayIdx][quarterIdx].size()); */
				
				auto& yearVec { (*tree)[yearIdx] };
				auto& monthVect { yearVec[monthIdx] };
				auto& dayVec { monthVect[dayIdx] };
				auto& quarterVec { dayVec[quarterIdx] };
				
				/* assert(quarterVec.empty()); */
				measurementIdx++;
				if (measurementIdx >= quarterVec.size()) {
					measurementIdx = 0;
					quarterIdx++;
					
					if (quarterIdx >= dayVec.size()) {
						quarterIdx = 0;
						dayIdx++;
						
						if (dayIdx >= monthVect.size()) {
							dayIdx = 0;
							monthIdx++;
							
							if (monthIdx >= yearVec.size()) {
								monthIdx = 0;
								yearIdx++;
								
								if (yearIdx >= tree->size()) {
									return -1;
								}
							}
						}
					}
				}
				/* Measurement& measurement { quarterVec[measurementIdx] }; */
				return 0;
			}
			
			void goToNextValid() {
				//FIXME: get the reference to the actual member vectors not the copies
				std::span yearVec { (*tree)[yearIdx] };
				std::span monthVec { yearVec[monthIdx] };
				std::span dayVec { monthVec[dayIdx] };
				std::span quarterVec { dayVec[quarterIdx] };
				
				while(quarterVec.empty() && yearIdx < tree->size()) {
					const auto end { incrementSafe() };
					
					if(end < 0) {
						break;	
					}
					
					yearVec = (*tree)[yearIdx];            
					monthVec = yearVec[monthIdx];       
					dayVec = monthVec[dayIdx];
					quarterVec = dayVec[quarterIdx];    			
				}
				
			}
			void decrementSafe() {
				std::span yearVec { tree[yearIdx] };
				std::span monthVec { yearVec[monthIdx] };
				std::span dayVec { monthVec[dayIdx] };
				std::span quarterVec { dayVec[quarterIdx] };
				std::span record { quarterVec[measurementIdx] };
				
				if(measurementIdx == 0) {
					measurementIdx = quarterVec.size() - 1;
					quarterIdx--;
				}
				
				if(quarterIdx == 0) {
					quarterIdx = dayVec.size() - 1;
					dayIdx--;
				}
				
				if(dayIdx == 0) {
					dayIdx = monthVec.size() - 1;
					monthIdx--;
				}
				
				if(monthIdx == 0) {
					monthIdx = yearVec.size() - 1;
					yearIdx--;
				}
			}
			public:
			Iterator(TreeType* _tree, size_t year = 0, size_t month = 0, size_t day = 0, size_t quarter = 0, size_t measurement = 0):
			tree(_tree),
			yearIdx(year),
			monthIdx(month),
			dayIdx(day),
			quarterIdx(quarter),
			measurementIdx(measurement) {
				if(tree != nullptr) {
					goToNextValid();
				}
			}
			
			Measurement& operator*() {
				auto measurements { (*tree)[yearIdx][monthIdx][dayIdx][quarterIdx] };
				
				assert(!measurements.empty());
				
				return (*tree)[yearIdx][monthIdx][dayIdx][quarterIdx][measurementIdx];
			}
			
			std::strong_ordering operator<=>(const Iterator& other) const {
				if(yearIdx == tree->size() && yearIdx == other.yearIdx) { // for end iterator
					return std::strong_ordering::equal;
				}
				
				if(yearIdx != other.yearIdx) {
					return yearIdx <=> other.yearIdx;
				} else if(monthIdx != other.monthIdx) {
					return monthIdx <=> other.monthIdx;
				} else if(dayIdx != other.dayIdx) {
					return dayIdx <=> other.dayIdx;
				} else if(quarterIdx != other.quarterIdx) {
					return quarterIdx <=> other.quarterIdx;
				} else {
					return measurementIdx <=> other.measurementIdx;
				} 
				
				return std::strong_ordering::equal;
			}	
			
			bool operator!=(const Iterator& other) const {
				return (*this <=> other) != std::strong_ordering::equal;
			}	
			
			Iterator operator++() {
				incrementSafe();
				goToNextValid();
				
				if(yearIdx >= tree->size()) {
					return Iterator(nullptr, tree->size());
				}
				
				return(*this);
			}
			
			Iterator operator--() {
				decrementSafe();
				
				return Iterator(
				tree,
				yearIdx,
				monthIdx,
				dayIdx,
				quarterIdx,
				measurementIdx
				);
			}
		};
		
		public:
		MeasurementsTree();
		
		Iterator begin(); 
		Iterator end(); 
		
		void generate_measurement_tree(std::vector<MeasurementRecord> records);
		TreeType get_tree(void) const;
	};
\end{lstlisting}

W pliku znajduje się definicja klasy \texttt{MeasurementsTree} oraz klasa wewnętrzna \texttt{Iterator}.
Klasa \texttt{Iterator} znajdująca się na wierszach od 16 do 182 służy do przechodzenia przez wszystkie pomiary w pięciopoziomowym zagnieżdżeniu wektorów. Zmienne w wierszach od 19 do 23 określają aktualną pozycję w drzewie.	Metoda \texttt{IncrementSafe} w wierszu 26 jest metodą pomocniczą do bezpiecznego przejścia do następnego elementu.
Metoda \texttt{GoToNextValid} w wierszach od 66 do 88 służy do przeskoku do następnego niepoustego wektora pomiarów.
Metoda \texttt{decrementSafe} w wierszach od 87 do 113 służy do cofania się.